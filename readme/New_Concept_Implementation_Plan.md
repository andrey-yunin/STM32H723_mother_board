# Финальный план перехода на табличную концепцию и дорожная карта

Этот документ описывает полный и утвержденный план перехода на табличную архитектуру обработки команд, а также предоставляет инструкцию (дорожную карту) для добавления новых команд в будущем.

## Часть 1: Начало работы

### 1.1. Откат к базовому коммиту

Проект начнется с чистого, рабочего состояния, в котором реализована логика `switch` с эмуляцией CAN-ответов.

**Действие:** Пожалуйста, выполните в вашем терминале следующую команду, чтобы сбросить состояние проекта до нужного коммита:

```bash
git reset --hard e6f423f
```

**ВНИМАНИЕ:** Эта команда перезапишет все локальные изменения. Убедитесь, что все, что вы хотите сохранить, закоммичено.

[ ] После выполнения команды, пожалуйста, подтвердите, и мы приступим к следующему шагу.

## Часть 2: Поэтапный план перехода

**Цель:** Безопасно и пошагово заменить `switch-case` в `command_parser.c` на две таблицы дескрипторов (для прямых и рецептурных команд).

---

### **Фаза 1: Подготовка инфраструктуры (только заголовочные файлы)**

1.  [x] **Обновить `command_parser.h`:**
    *   [x] **Действие:** Добавить определения для `DirectCommandHandler_t` (указатель на функцию), `DirectCommandDescriptor_t` и `RecipeCommandDescriptor_t`.
    *   [x] **Файл:** `App/Inc/Dispatcher/command_parser.h`

2.  [x] **Создать `direct_command_handlers.h`:**
    *   [x] **Действие:** Создать новый заголовочный файл для прототипов функций-обработчиков прямых команд.
    *   [x] **Файл (новый):** `App/Inc/Dispatcher/direct_command_handlers.h`

3.  [x] **Создать `direct_command_handlers.c`:**
    *   [x] **Действие:** Создать соответствующий, пока пустой, файл реализации для этих обработчиков.
    *   [x] **Файл (новый):** `App/Src/Dispatcher/direct_command_handlers.c`

[x] **Результат Фазы 1:** Все необходимые структуры и файлы созданы. Код компилируется, но его поведение не изменилось.

---

### **Фаза 2: Пошаговый рефакторинг (гибридный режим)**

1.  [x] **Рефакторинг `INIT` (первая команда-рецепт):**
    *   [x] **Действия:**
        1.  [x] В `command_parser.c` создать массив `recipe_command_table[]` и добавить в него дескриптор для `INIT` (код `0x1002`).
        2.  [x] Изменить `Parser_ProcessBinaryCommand`: добавить поиск по `recipe_command_table`. Если команда найдена — вызвать `JobManager_StartNewJob`. Если нет — выполнение переходит к старому `switch`.
        3.  [x] Удалить `case 0x1002` (INIT) из `switch-case`.
    *   [x] **Тестирование:** Убедиться, что `INIT` работает через новую систему, а все остальные команды продолжают работать по-старому.

2.  [ ] **Рефакторинг `GET_STATUS` (первая прямая команда):**
    *   [ ] **Действия:**
        1.  [ ] В `direct_command_handlers.c` реализовать функцию `handle_get_status`.
        2.  [ ] В `command_parser.c` создать массив `direct_command_table[]` и добавить в него дескриптор для `GET_STATUS` (код `0x1000`).
        3.  [ ] Дополнить логику `Parser_ProcessBinaryCommand`: в самом начале добавить поиск по `direct_command_table`. Если команда найдена, вызывается ее обработчик. Если нет - идет поиск по `recipe_command_table`, и только потом переход к `switch`.
        4.  [ ] Удалить обработку `GET_STATUS` из `switch-case`.
    *   [ ] **Тестирование:** Убедиться, что `GET_STATUS` работает через новую систему, `INIT` по-прежнему работает, а остальные команды работают через `switch`.

---

### **Фаза 3: Полная миграция и очистка**

1.  [ ] **Перенос оставшихся команд:**
    *   [ ] **Действие:** Поочередно перенести все оставшиеся команды (`DISPENSER_WASH` и т.д.) из `switch-case` в соответствующие таблицы дескрипторов.
    *   [ ] **Тестирование:** После переноса каждой команды проводить полное тестирование.

2.  [ ] **Удаление `switch-case`:**
    *   [ ] **Действие:** Когда все `case` будут перенесены, полностью удалить конструкцию `switch`. Логика `default` (обработка неизвестной команды) будет выполняться, если команда не найдена ни в одной из таблиц.

---

### **Фаза 4: Финальное тестирование и документация**

1.  [ ] **Обновить тестовый набор:**
    *   [ ] **Действие:** Создать или обновить `App_user/test_suite.py` для автоматической проверки всех команд.
2.  [ ] **Обновить документацию:**
    *   [ ] **Действие:** Внести изменения в `README.md` и другие документы, чтобы они отражали новую архитектуру.

---

## Часть 3: Дорожная карта добавления новых команд

Эта инструкция описывает процесс добавления новой команды после полного перехода на табличную архитектуру.

### [ ] **Шаг 1. Определите тип команды**

[ ] Это **"прямая"** команда (простое, немедленное действие, как `GET_STATUS`) или **"команда-рецепт"** (сложный, многошаговый процесс, как `INIT`)?

### [ ] **Шаг 2. Реализуйте логику**

#### [ ] **Если это "команда-рецепт":**

1.  [ ] **Добавьте ID рецепта** в `enum RecipeID_t` в файле `App/Inc/Dispatcher/command_parser.h`.
    ```c
    // App/Inc/Dispatcher/command_parser.h
    typedef enum {
        // ... существующие ID ...
        RECIPE_NEW_COMPLEX_TASK, // <-- Ваша новая команда
        RECIPE_MAX_ID
    } RecipeID_t;
    ```
2.  [ ] **Создайте сам рецепт** (последовательность шагов `ProcessStep_t`) в файле `App/Src/Dispatcher/recipe_store.c`.
3.  [ ] **Зарегистрируйте команду:** Добавьте новую запись в массив `recipe_command_table[]` в файле `App/Src/Dispatcher/command_parser.c`.
    ```c
    // App/Src/Dispatcher/command_parser.c
    const RecipeCommandDescriptor_t recipe_command_table[] = {
        // ... существующие дескрипторы ...
        {
            .command_code = 0xAAAA, // <-- Код вашей новой команды
            .min_params_len = X,
            .max_params_len = Y,
            .recipe_id = RECIPE_NEW_COMPLEX_TASK
        },
    };
    ```

#### [ ] **Если это "прямая" команда:**

1.  [ ] **Объявите обработчик:** Добавьте прототип вашей новой функции-обработчика в `App/Inc/Dispatcher/direct_command_handlers.h`.
    ```c
    // App/Inc/Dispatcher/direct_command_handlers.h
    // ... существующие прототипы ...
    void handle_new_direct_task(uint16_t command_code, const uint8_t* params, uint16_t params_len); // <-- Ваш новый обработчик
    ```
2.  [ ] **Реализуйте обработчик:** Напишите логику функции в `App/Src/Dispatcher/direct_command_handlers.c`.
3.  [ ] **Зарегистрируйте команду:** Добавьте новую запись в массив `direct_command_table[]` в файле `App/Src/Dispatcher/command_parser.c`.
    ```c
    // App/Src/Dispatcher/command_parser.c
    const DirectCommandDescriptor_t direct_command_table[] = {
        // ... существующие дескрипторы ...
        {
            .command_code = 0xBBBB, // <-- Код вашей новой команды
            .min_params_len = Z,
            .max_params_len = W,
            .handler = handle_new_direct_task
        },
    };
    ```

### [ ] **Шаг 3. Протестируйте**

[ ] Добавьте новый тест в `App_user/test_suite.py`, чтобы убедиться, что ваша новая команда работает корректно и не нарушает работу существующих.