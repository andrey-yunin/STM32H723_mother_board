# План развития проекта DDS 240: Анализ текущего состояния и дорожная карта модернизации

## Дата: Пятница, 23 января 2026 г.

Этот документ фиксирует текущий статус проекта, результаты последнего анализа и утвержденный план дальнейших действий по модернизации, строго придерживаясь существующей архитектуры обработки команд на основе `switch-case`.

---

## 1. Анализ выполнения `test_combined_commands.py`

**Общий результат:**
Скрипт `test_combined_commands.py` успешно завершил все проверки, сообщив "ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!". Это означает, что с точки зрения хост-приложения Python, все отправленные команды были подтверждены, и все ожидаемые пакеты ответов (ACK, DATA, DONE) были получены с ожидаемыми кодами статуса.

**Детальный анализ по командам:**

1.  **Команда `INIT` (0x1002):**
    *   **Внутренние логи устройства:**
        *   `INFO: Job #X started (Recipe ID:3).` - Задача инициализации (Job) успешно запущена.
        *   `DEBUG: Job #X: Action for motor_id=2 filtered out by mask.` - **Критическое наблюдение:** Действие, предназначенное для `motor_id=2` (вероятно, часть процедуры инициализации), было *пропущено* из-за некой внутренней "маски". Это означает, что `motor_id=2` не выполнил свое действие на этом шаге.
        *   `INFO: Job #X finished with status 3.` - **Критическое наблюдение:** Внутренний `JobManager` регистрирует завершение задачи с внутренним `статусом 3`.
    *   **Внешний протокол (ответ хосту):** `Получен DONE для 0x1002 со статусом 0x0000.` Хост получает пакет `DONE` со статусом `0x0000` (Успех).
    *   **Несоответствие:** Существует расхождение между внутренним результатом `JobManager` (`статус 3`) и тем, что сообщается внешнему хосту (`0x0000`). Это является ключевым "сбоем в ответе", так как внутреннее состояние не соответствует внешнему отчету об успехе. Фильтрация `motor_id=2` может способствовать этому внутреннему статусу `3`, если это действие было обязательным для полного "успеха".

2.  **Команда `GET_STATUS` (0x1000):**
    *   **Внутренние логи устройства:** `DEBUG: Signaling system READY.` - Устройство явно сообщает о переходе системы в состояние `READY`.
    *   **Внешний протокол (ответ хосту):** Хост успешно получает `ACK`, пакет `DATA` (`0x02 0x00 0x00`, что соответствует `System State = 0x02` - `READY`) и `DONE` (`0x0000` статус).
    *   **Анализ:** Команда функционирует ожидаемым образом.

**Резюме анализа:**
Скрипт `test_combined_commands.py` проходит свои проверки для команд `INIT` и `GET_STATUS`. Однако внутренние логи устройства выявляют:
*   Несоответствие статуса выполнения `INIT`: `JobManager` внутренне сообщает `статус 3`, в то время как внешний `DONE` пакет сообщает `0x0000` (Успех).
*   Последовательную фильтрацию действия для `motor_id=2` во время `INIT`, что может указывать на неполное выполнение процедуры инициализации.
Это подтверждает наличие "сбоя в ответе", где внутреннее поведение не всегда точно отражается во внешних отчетах.

---

## 2. Утвержденный план дальнейшей модернизации (Сфокусированный подход)

Этот план строго придерживается существующей архитектуры на основе `switch-case` и направлен на решение выявленных "сбоев в ответе" и обеспечение корректной обработки команд.

### **Фаза 1: Уточнения и Настройка (Исследование)**

*   [x] **1.1 Исследование внутреннего статуса `JobManager`:**
    *   **Действие:** Найти определение внутренних кодов статуса задачи (например, `JobStatus_t` enum/defines) в `App/Src/Dispatcher/job_manager.c` или связанных заголовочных файлах.
    *   **Цель:** Понять, что означает `статус 3`, и скорректировать внешнее сообщение статуса `DONE`, если необходимо, чтобы оно соответствовало внутреннему состоянию.
    *   **Результат:** `status 3` соответствует `JOB_STATUS_COMPLETED` и корректно отображается как `0x0000` (Успех) во внешнем протоколе. **Проблемы нет.**

*   [x] **1.2 Исследование фильтрации действий двигателя:**
    *   **Действие:** Определить, где происходит фильтрация действий для `motor_id=2` (например, в `job_manager.c` или `recipe_store.c`).
    *   **Цель:** Установить, является ли это поведение преднамеренным. Если нет, устранить проблему для обеспечения полной инициализации.
    *   **Результат:** Фильтрация `motor_id=2` является **преднамеренным поведением**, основанным на маске модулей, переданной с командой `INIT`. **Проблемы нет.**

### **Фаза 2: Немедленные исправления и Целевая интеграция (в рамках существующей структуры `switch`)**

*   [ ] **2.1 Реализация обработки `DISPENSER_WASH` (0x2000):**
    *   [ ] **Действие A:** Добавить `RECIPE_DISPENSER_WASH` в `RecipeID_t`.
        *   **Файл:** `App/Inc/Dispatcher/command_parser.h`
    *   [ ] **Действие B:** Добавить определение `g_recipe_dispenser_wash` в `App/Src/Dispatcher/recipe_store.c` и обновить `Recipe_Get` для его возврата. Этот рецепт будет определять шаги для промывки дозатора.
        *   **Файл:** `App/Src/Dispatcher/recipe_store.c`
    *   [ ] **Действие C:** Добавить `case 0x2000` для `DISPENSER_WASH` в `Parser_ProcessBinaryCommand` в `App/Src/Dispatcher/command_parser.c`. Этот `case` будет извлекать параметры (`dispenser_id`, `volume`, `cycles` согласно документации) и вызывать `JobManager_StartNewJob`.
    *   [ ] **Действие D:** Добавить новый тестовый случай для `DISPENSER_WASH` в `App_user/test_combined_commands.py`.

*   [ ] **2.2 Исправление нарушения протокола `UNKNOWN_COMMAND` (0xFFFF):**
    *   [ ] **Действие A:** Изменить `default` случай в `Parser_ProcessBinaryCommand` в `App/Src/Dispatcher/command_parser.c` для отправки *только* `NACK` (без предшествующего `ACK`) для действительно неизвестных команд.
    *   [ ] **Действие B:** Добавить новый тестовый случай для `UNKNOWN_COMMAND` в `App_user/test_combined_commands.py`.

*   [ ] **2.3 Интеграция `GET_STATUS` (0x1000) для прямой обработки:**
    *   [ ] **Действие A:** Создать новый заголовочный файл: `App/Inc/Dispatcher/direct_command_handlers.h`. Этот файл будет объявлять прототип для `handle_get_status`.
    *   [ ] **Действие B:** Создать новый файл исходного кода: `App/Src/Dispatcher/direct_command_handlers.c`. Этот файл будет реализовывать `handle_get_status`, которая будет получать состояние системы и последнюю ошибку, затем отправлять пакет `DATA`, за которым следует пакет `DONE`.
    *   [ ] **Действие C:** Изменить `case 0x1000` в `Parser_ProcessBinaryCommand` в `App/Src/Dispatcher/command_parser.c` для прямого вызова `handle_get_status`.