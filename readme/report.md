# Отчет о текущем состоянии проекта (14 января 2026 г.)

## Цель текущей задачи:
Реализовать и протестировать параметризованное выполнение команд на основе архитектуры "Рецепт - Ингредиенты" с использованием фильтрующей логики.

## Проделанная работа:

### 1. Изучение документации и рефакторинг:
*   Проведен полный архитектурный рефакторинг с внедрением универсальной структуры команд `UniversalCommand_t`.

### 2. Реализация базового бинарного протокола:
*   Реализован и протестирован базовый бинарный протокол (прием команды, отправка ACK).
*   Все ключевые модули (`command_parser`, `job_manager`, `dispatcher`, etc.) адаптированы под `UniversalCommand_t`.

### 3. Реализация и тестирование фильтрующей логики:
*   **`App/Src/Dispatcher/job_manager.c`**: В функцию `JobManager_ExecuteStep` добавлена логика фильтрации для `RECIPE_INITIALIZE_SYSTEM`.
*   **Тестирование**: Проведены тесты с масками `0x01` и `0x02`, которые подтвердили корректную работу фильтрации. Тесты с масками `0x03` и `0x00` выявили проблему блокировки из-за отсутствия ответов от исполнителей, что является ожидаемым поведением на данном этапе.

### Текущий статус:
*   **Фильтрующая логика реализована корректно.** `JobManager` способен динамически пропускать действия в статическом рецепте на основе runtime-параметров.
*   Дальнейшее тестирование и реализация более сложных, многошаговых рецептов **заблокированы** отсутствием ответов от исполнителей по CAN-шине.

---
## Архитектурная концепция: Обработка команд

Этот раздел описывает фундаментальные принципы, заложенные в основу модуля `Dispatcher`, который отвечает за выполнение команд, поступающих от пользователя.

### 1. Принцип "Рецепт - Ингредиенты"

В основе системы лежит простая и мощная аналогия с кулинарией, которая помогает разделить ответственность между модулями.

*   **Ингредиенты (`AtomicAction_t`)**: Это самые простые, неделимые действия, которые может выполнить система. Каждое действие имеет свой тип (`ActionType_t`) и параметры.
    *   *Пример: `{ действие: ACTION_ROTATE_MOTOR, параметры: { id: 1, шаги: 1000, скорость: 500 } }` — это один "ингредиент".

*   **Шаги (`ProcessStep_t`)**: Это группа из одного или нескольких "ингредиентов", которые должны выполняться **одновременно (параллельно)**. `JobManager` не перейдет к следующему шагу, пока не завершатся все действия текущего.
    *   *Пример: одновременное включение насоса и запуск таймера — это один шаг, состоящий из двух ингредиентов.*

*   **Рецепты (массив `ProcessStep_t[]`)**: Это полная, упорядоченная последовательность шагов, необходимая для выполнения сложной задачи (например, "взять реагент"). Рецепты статичны и хранятся во flash-памяти в файле `recipe_store.c`.

*   **Поваренная книга (`recipe_store.c`)**: Это хранилище всех известных системе рецептов.

*   **Шеф-повар (`JobManager`)**: Это "мозг" системы. Его задача — взять запрошенный `recipe_id`, найти соответствующий рецепт в "поваренной книге" и скрупулезно, шаг за шагом, выполнить все перечисленные в нем действия. По своей базовой природе, `JobManager` — это универсальный и "слепой" исполнитель рецептов.

### 2. Параметризация рецептов: Фильтрующая логика

Проблема статических рецептов в том, что они негибкие. Команда `INIT`, например, должна уметь инициализировать как все модули сразу, так и только один выбранный. Создавать отдельный рецепт для каждой комбинации нецелесообразно.

Здесь в игру вступает **"фильтрующая логика"**.

#### Аналогия: Заказ с особыми пожеланиями

Представьте, что клиент заказывает "Стейк рибай, **но без грибов**".
*   **Технологическая карта (рецепт)** на кухне не меняется, в ней по-прежнему есть шаг "обжарить грибы".
*   **Шеф-повар (`JobManager`)**, получив заказ с пометкой "без грибов", следует рецепту, но, дойдя до шага с грибами, он **видит пометку и просто пропускает его**.
*   Он не меняет рецепт, а лишь **фильтрует** его "ингредиенты" на лету в соответствии с "заказом" (`UniversalCommand_t`).

#### Применение в коде (на примере команды `INIT`)

1.  **"Заказ"**: `Parser_ProcessBinaryCommand` получает команду `INIT` с маской модулей (например, `0x01` — только мотор №1).
2.  **"Рецепт"**: `g_recipe_initialize_system` в `recipe_store.c` содержит полный список действий для инициализации **всех** моторов.
3.  **"Фильтрующая логика" (внутри `JobManager_ExecuteStep`):**
    *   `JobManager` начинает выполнять полный рецепт `g_recipe_initialize_system`.
    *   Для каждого действия `ACTION_HOME_MOTOR` в рецепте он выполняет проверку:
        1.  Это рецепт `INIT`? Да.
        2.  Это действие `HOME_MOTOR`? Да.
        3.  Значит, нужно применить фильтр. `JobManager` смотрит на маску `0x01` из "заказа".
        4.  Он проверяет: "Нужно ли выполнять `homing` для мотора, указанного в этом действии, согласно маске?"
        5.  **Если да**, действие выполняется (отправляется CAN-команду).
        6.  **Если нет**, действие пропускается, и, что критически важно, **уменьшается счетчик ожидаемых ответов (`pending_actions_count--`)**, чтобы `JobManager` не завис в ожидании.

#### Преимущества этого подхода

*   **Чистая архитектура**: `recipe_store.c` — это просто "база данных" о том, *что* можно сделать. Вся сложная логика инкапсулирована в `job_manager.c`.
*   **Гибкость и масштабируемость**: Для добавления нового мотора достаточно будет дописать его в статический рецепт. `JobManager` уже умеет с ним работать. Для создания новой параметризуемой команды (например, `WASH_CUVETTES 1,3,5`) мы сможем использовать этот же принцип фильтрации.

---

## Дорожная карта: Добавление новой команды в проект

Этот раздел служит инструкцией для разработчиков по добавлению новых бинарных команд в систему, сохраняя при этом целостность архитектуры "Рецепт - Ингредиенты".

### Шаг 1: Проектирование команды

Прежде чем писать код, необходимо определить:

1.  **Назначение команды:** Что она должна делать? (например, "Промыть кювету").
2.  **Код команды:** Выбрать уникальный код (например, `0x4000`).
3.  **Параметры:** Нужны ли ей аргументы?
    *   **Нет параметров** (например, `GET_STATUS`).
    *   **Параметры-фильтры** (как в `INIT`): аргументы используются для фильтрации действий в статическом рецепте.
    *   **Параметры-значения** (например, `ROTATE_MOTOR`): аргументы (ID мотора, кол-во шагов) используются для задания конкретных значений в действиях рецепта. *(Эта логика будет реализована в будущем, но ее нужно учитывать).*
4.  **Ответы:** Какие ответы должна возвращать команда (`ACK`, `DONE`, `ERROR`, `DATA`)?

### Шаг 2: Процесс реализации (Пошаговая инструкция)

Чтобы добавить новую команду, найдите в коде комментарии-якоря `// --- [ADD_NEW_COMMAND] ---` и следуйте пронумерованным шагам:

1.  **`App/Inc/Dispatcher/command_parser.h`**: Добавить новый `enum` для рецепта (`RECIPE_...`).
2.  **`App/Src/Dispatcher/command_parser.c`**: Добавить новый `case` для кода команды в `Parser_ProcessBinaryCommand`.
3.  **`App/Src/Dispatcher/recipe_store.c`**: Создать массив `const ProcessStep_t[]` с полным рецептом.
4.  **`App/Src/Dispatcher/recipe_store.c`**: Добавить `case` для нового рецепта в `Recipe_Get`.
5.  **`App/Src/Dispatcher/job_manager.c`**: Если команда параметризованная, добавить `else if` в логику фильтрации в `JobManager_ExecuteStep`.
6.  **Тестирование**: Обновить `App_user/test_protocol.py` для тестирования новой команды.
