# План работ: Завершение реализации параметризованных рецептов

## Цель этапа:
Реализовать и протестировать механизм, позволяющий `JobManager`'у выполнять статические рецепты, но динамически фильтровать действия ("ингредиенты") внутри этих рецептов на основе аргументов, переданных в изначальной команде. Это будет реализовано на примере команды `INIT`.

## Выполненные шаги:
*   Реализован и протестирован базовый бинарный протокол (прием команды, отправка ACK).
*   Проведен архитектурный рефакторинг с внедрением `UniversalCommand_t` для гибкой передачи аргументов.
*   Задокументирована архитектурная концепция и дорожная карта.
*   **Реализована и протестирована фильтрующая логика в `JobManager_ExecuteStep` для команды `INIT`.**
    *   Проведены тесты с масками `0x01`, `0x02` и `0x03`, подтвердившие корректную работу фильтрации и отправку соответствующих CAN-команд.
    *   Тест с маской `0x00` показал, что задание корректно фильтрует все действия, но не завершается из-за отсутствия ответов по CAN-шине (зависает).

## Оставшиеся шаги реализации:

### 1. Имитация ответов от CAN-исполнителей для полного тестирования:
*   **1.1. Адаптация `JobManager_ExecuteStep`**:
    *   Временно модифицировать `JobManager_ExecuteStep` для имитации мгновенного успешного ответа от исполнителя сразу после отправки CAN-команды.
    *   **Реализация:** Сразу после каждого вызова `xQueueSend(can_tx_queue_handle, ...)` в `switch-case` добавить вызов `JobManager_ProcessExecutorResponse(job->job_id, action->params.home_motor.motor_id, true)`. (Будем использовать ID мотора как `executor_id` для `HOME_MOTOR`).

### 2. Добавление функций для ответов о завершении:
*   **2.1. Добавление `Dispatcher_SendDone` и `Dispatcher_SendError`**:
    *   Создать в `dispatcher_io.h` и `dispatcher_io.c` функции для отправки `DONE`- и `ERROR`-ответов согласно протоколу.
    *   Эти функции будут использоваться `JobManager`'ом из `JobManager_CompleteJob` после завершения выполнения заданий.
*   **2.2. Тестирование ответов**:
    *   Модифицировать `test_protocol.py` так, чтобы он слушал порт дольше и ожидал получения `DONE` или `ERROR` после `ACK`.

## Зависимости:
*   FreeRTOS (Stream Buffer API, Queue API, Semaphore API).
*   Correct operation of USB CDC.
*   Наличие и корректная работа `JobManager`.

## Тестирование:
*   После каждого шага, компиляция и проверка на отсутствие ошибок.
*   Использование `App_user/test_protocol.py` для валидации бинарного обмена.
```